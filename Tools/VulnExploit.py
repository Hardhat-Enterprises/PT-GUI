import os
import time
from subprocess import check_output

from pymetasploit3.msfrpc import MsfRpcClient

global global_positive_out
global_positive_out = list()
global global_console_status
global_console_status = False


# kill msfrpc process
def close_msfrpc(process):
    process_close = int(check_output(['pidof', process]))
    os.system('kill ' + str(process_close))


# display console data from terminal
def read_console(console_data):
    global global_console_status
    global_console_status = console_data['busy']

    if ('[+]' in console_data['data']):
        sigdata = console_data['data'].rstrip().split('\n')
        for line in sigdata:
            if ('[+]' in line):
                global_positive_out.append(line)
    print(console_data['data'])


# search Metasploit for exploit with user input
def search_exploit(console):
    loop = 1
    while loop != 0:
        print("=====================================")
        print("Search Metasploit for an exploit")
        print("=====================================")
        exploit_str = input("Search for an exploit (enter exit to return to main menu): ")
        if exploit_str == 'exit':
            loop = 0
        else:
            # search for exploits only
            console.write('search type:exploit ' + exploit_str)
            if console.is_busy():
                time.sleep(1)
            search = console.read()
            read_console(search)
            time.sleep(2)


# open exploit and display information about exploit
def information_exploit(console):
    loop = 1
    while loop != 0:
        print("=====================================")
        print("Copy an exploit found in Search Exploit and paste in to ")
        print("found more information about that exploit")
        print("=====================================")
        exploit_str = input("Information on an exploit (enter exit to return to main menu): ")
        if exploit_str == 'exit':
            loop = 0
        else:
            module = exploit_str.split('/')[0]
            exploit_new_str = exploit_str.split(module + '/')
            # check if module is exploit
            if module == 'exploit':
                if (exploit_str != ''):
                    # open exploit and show info
                    console.write('use ' + exploit_str)
                    console.write('info')
                    exploit = client.modules.use('exploit', exploit_new_str[1].rstrip())
                    if console.is_busy():
                        time.sleep(1)
                    information = console.read()
                    read_console(information)
                    time.sleep(1)
                    # Display information about exploit required fields
                    print("================================================")
                    print("This Exploit needs user input for the fields below: ")
                    for missing in exploit.missing_required:
                        print(missing)
                    print("================================================")
                    # display list of all payload exploit can use
                    if module == 'exploit':
                        print("Payload that work with target")
                        for payload in exploit.payloads:
                            print(payload)
                        print("================================================")
                time.sleep(2)
            else:
                print("Enter exploit with exploit as first directory")


# exploit vulnerability, user enters required information about target
def exploit_vulnerability(console):
    loop = 1
    while loop != 0:
        print("=====================================")
        print("Copy an exploit found in Search Exploit and used in")
        print("Information about Exploit")
        print("Paste exploit here to use exploit")
        print("=====================================")
        exploit_str = input("Enter Exploit (enter exit to return to main menu): ")
        if exploit_str == 'exit':
            loop = 0
        else:
            required_exploit = list()
            required_payload = list()
            module = exploit_str.split('/')[0]
            exploit_new_str = exploit_str.split(module + '/')
            # check if module is exploit
            if module == 'exploit':
                exploit = client.modules.use('exploit', exploit_new_str[1].rstrip())
                if console.is_busy():
                    time.sleep(1)
                # list of missing fields
                for missing in exploit.missing_required:
                    required_exploit.append(missing)
                # loop while missing required is not empty or zero
                while len(required_exploit) != 0:
                    # add missing fields
                    # note: if statements not complete
                    for missing in exploit.missing_required:
                        correct_value = 'N'
                        while correct_value != 'Y':
                            set_value = input("Set Exploit - " + missing + ": ")
                            value = input("Is this correct " + missing + " set to " + set_value + ". Y/N: ")
                            if value == 'Y' or value == 'y':
                                exploit[missing] = set_value
                                required_exploit.remove(missing)
                                correct_value = 'Y'
                # set payload when missing required field is empty
                global payload
                # payload
                # set exploit payload
                correct_value = 'N'
                while correct_value != 'Y':
                    payload_value = input("Set Payload: ")
                    value = input("Is this correct Payload set to " + payload_value + ". Y/N: ")
                    if value == 'Y' or value == 'y':
                        payload_str = "'" + payload_value + "'"
                        payload = client.modules.use('payload', payload_value)
                        if console.is_busy():
                            time.sleep(1)
                        correct_value = 'Y'
                # payload missing fields
                for missing in payload.missing_required:
                    required_payload.append(missing)
                if len(required_payload) != 0:
                    print("=====================================")
                    print("Payload is missing required fields")
                while len(required_payload) != 0:
                    for missing in payload.missing_required:
                        correct_value = 'N'
                        while correct_value != 'Y':
                            set_value = input("Set Payload - " + missing + ": ")
                            value = input("Is this correct " + missing + " set to " + set_value + ". Y/N: ")
                            if value == 'Y' or value == 'y':
                                payload[missing] = set_value
                                required_payload.remove(missing)
                                correct_value = 'Y'
                # launch exploit
                print("=====================================")
                print("Launching Exploit")
                print_exploit = console.run_module_with_output(exploit, payload=payload)
                run_exploit = exploit.execute(payload=payload)
                if console.is_busy():
                    time.sleep(1)
                print(print_exploit)
                time.sleep(4)
                return run_exploit


# open session created from successful exploit
def session(exploit):
    # check if there is a session
    if len(client.sessions.list) == 0:
        print("There is no Active Sessions at the moment")
    # check session list for session created by our exploit
    else:
        session_list = client.sessions.list
        global shell
        for session in session_list:
            if (session_list[session]['exploit_uuid'] == exploit['uuid']):
                shell = client.sessions.session(session)
        # open session and loop command till exit condition
        exit_condition = 1
        # \b *> for meterpreter
        # \bC: for windows
        end_strings = ['\b *>', '\bC:']
        while exit_condition != 0:
            command_input = input("Enter Commands (enter exit to return to main menu): ")
            if command_input == 'exit':
                exit_condition = 0
            else:
                print(shell.run_with_output(cmd=command_input, end_strs=end_strings))


# menu information
def menu_information(id):
    # Menu
    if id == 'first_menu':
        print("=====================================")
        print("\t\t\t Vulnerability Exploit Tool")
    if id == 'menu_loop' or id == 'first_menu':
        print("=====================================")
        print("\t\t\t Menu")
        print("=====================================")
        print("\t1: \tSearch for Exploit")
        print("\t2: \tInformation about Exploit")
        print("\t3: \tUse Exploit")
        print("\t4: \tSession")
        print("\t5: \tExit")


def program_menu():
    # menu
    menu_information('first_menu')
    # program loop
    program = 1
    global exploit
    exploit = ''
    while (program != 0):
        print("=====================================")
        userinput = input("Enter choice: ")
        if (userinput == '1'):
            search_exploit(console)
        if (userinput == '2'):
            information_exploit(console)
        if (userinput == '3'):
            exploit = exploit_vulnerability(console)
        if (userinput == '4'):
            print("=====================================")
            print("Not Tested with successful exploit")
            print("=====================================")
            # check if there is a session
            if exploit == '':
                print("There is no exploit in use at the moment")
            else:
                session(exploit)
        if (userinput == '5' or userinput == 'exit'):
            print("=====================================")
            print("\t\t\t Exiting Vulnerability Exploit")
            print("=====================================")
            program = 0
        # display menu after returning to main program from functions
        if program != 0:
            menu_information('menu_loop')


# start Msfrpc
msfrpcStart = 'msfrpcd -P password -S'
os.system(msfrpcStart)
time.sleep(8)

client = MsfRpcClient('password', port=55553)
# open console
cid = client.consoles.console().cid
console = client.consoles.console(cid)
console.read()

# clear terminal
os.system('clear')

program_menu()

# clean program
close_msfrpc('msfrpcd')

"""
References
https://github.com/DanMcInerney/pymetasploit3
Repository where 'pymetasploit3.msfrpc' module is imported from.
Used as a guide for communication with MSFRPC framework.

https://www.coalfire.com/the-coalfire-blog/may-2019/pymetasploit3-metasploit-automation-library
Used as a guide to using pymetasploit3 to create an exploit

https://stackoverflow.com/questions/26688936/how-to-get-pid-by-process-name
Used to help define close_msfrpc()' function.

https://infosec.smashedpixels.pro/metasploit-automatization-using-python/
Used in session function to help find session and read console function
"""
